# Signed Modal Tableaux

Tableaux are certain (downward-branching) trees of signed formulas. 
A tableau begins with a number of assumptions. Each further signed formula is generated by applying one of the inference rules.
Some inference rules add one or more signed formulas to a tip of the tree, others add two new tips, resulting in two branches.

For modal logics, we have to both extend the notion of signed formula and add rules that cover □ and ◇ In addition to a sign(T or F), formulas in modal tableaux also have prefixes 𝜎. The prefixes are non-empty sequences of positive integers, i.e., 𝜎 ∈ (Z+)∗ \ {𝛬}. When we write such prefixes without the surrounding ⟨ ⟩, and separate the individual elements by .’s instead of ,’s. If 𝜎 is a prefix, then 𝜎.n is 𝜎 ⌢ ⟨n⟩; e.g., if 𝜎 = 1.2.1, then 𝜎.3 is 1.2.1.3. So for instance,
1.2 T □A → A
is a prefixed signed formula (or just a prefixed formula for short).
## Input Format Specification
The input to a Signed Modal Tableaux proof is the extensions of Propositional Formula by the operators □ (“box”) and ◇ (“diamond”), which is attached to formulas.


## State Format Specification

The state representation returned by most endpoints is a JSON object.
Some of the object's properties are for internal use only and are subject to change at any time.
The state object is intended to be read-only and any modification may lead to the state being rejected by the API.
The only property that a visualization frontend should rely on is the `nodes` list.

The `nodes` lists contains all TreeNodes of the current proof tree.
A TreeNode is identified by its position in the list starting at zero.
Each TreeNode has the properties `parent` and `children`, containing the IDs of the respective parent and child TreeNodes.
The parent of the root TreeNode is `null`. Additionally, TreeNodes have an `isClosed` flag, `prefix` list and `sign` flag.
TreeNodes in a subtree that is completely closed will have the `isClosed` flag set.
closed leaves have the ID of the node they were closed with set as `closeRef`.
For all other nodes, `closeRef` is `null`.
`prefix` is a list of positive integers. The prefix names a world in a model that might satisfy the formulas on a branch of a tableau, and if 𝜎 names some world, then 𝜎.n names a world accessible from (the world named by) 𝜎.

`sign` is a Boolean value of the formula. 

## Rule Specification

### Basic Moves

Basic Moves are: `Negation`, `Alpha`, `Beta`, `Nu`, `Pi`, 
These Moves add one or two TreeNodes to the proof tree and set the children and parent properties respectively. 

`Negation`, `Alpha`, `Beta` are encoded as 
```json
{
  "type": <identifier for the move>, 
  "nodeID": <ID of the TreeNode to to apply the move on>, 
  "leafID": <ID of leaf , where the child should be attatched to`>, 
}
```

`Nu`, `Pi` are encoded as 
```json
{
  "type": <identifier for the move>, 
  "nodeID": <ID of the TreeNode to to apply the move on>, 
  "leafID": <ID of leaf , where the child should be attatched to`>,
  "prefix": <Prefix that should be used>, 
}
```

### Prune

The Prune move can be used to delete a whole subtree in case a mistake was made or the user wants to find a quicker proof.
Prune takes a node and recursively deletes all children nodes.

Prune is encoded as 
```json
{
  "type": "prune", 
  "nodeID": <ID of TreeNode which childrens are to be deleted>, 
}
```

### Undo

The undo move reverts the latest move and reverts the state to the point before executing the last move.
Undo uses only the `tree` property to decide which move needs to be undone, by using the fact that new TreeNodes will always be added to the end of `tree`. This is why undo cannot be used to undo a `prune` move

Undo moves are encoded as
```json
{
  "type": "undo"
}
```

## Closing a Proof

When a branch contains both T A and F A, we say the branch is closed. 
If every branch in a tableau is closed, the entire tableau is closed.
 A closed tableau consititues a derivation that shows that the set of signed formulas which were used to begin the tableau are unsatisfiable. 
